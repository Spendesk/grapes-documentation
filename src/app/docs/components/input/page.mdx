import { Preview } from "@/lib/preview/preview";

import {
  DemoNumberInput,
  DemoEmailInput,
  DemoNumberConstraint,
  DemoStringConstraint,
} from "./demo";

:::warning{title="Usage"}
Consider using this component as a last resort when none of the other available Grapes components meet your requirements, such as:

- [TextInput](/docs/components/text-input)
- [AmountInput](/docs/components/amount-input)

The primary difference between using an `Input` component versus a `TextInput` component is the ability to specify the `type` attribute with `Input`.
[Here are the list of type available.](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types)

:::

## Build a number input

<Preview>
  <DemoNumberInput />
</Preview>

```tsx
const Demo = () => {
  const [value, setValue] = useState(0);

  return (
    <FormField label="Quantity">
      <Input
        placeholder="Enter a quantity"
        type="number" // [!code highlight]
        value={value}
        onChange={(event) => {
          setValue(event.target.valueAsNumber);
        }}
      />
    </FormField>
  );
};
```

## Build a email input

You can take advantage of the browser's built-in email validation to verify whether an email address is valid.

:::warning{title="Usage"}
Built-in email validation is often too permissive, so it's recommended to use a custom regex or a validation library like [yup](https://www.npmjs.com/package/yup) for more accurate email validation.
:::

<Preview>
  <DemoEmailInput />
</Preview>

```tsx
const Demo = () => {
  const [value, setValue] = useState(0);
  const [error, setError] = useState(false);

  return (
    <FormField label="Email" alertMessage={error ? "Email invalid" : undefined}>
      <Input
        placeholder="Enter your email"
        type="email" // [!code highlight]
        value={value}
        onChange={(event) => {
          setError(!event.target.checkValidity()); // [!code highlight]
          setValue(event.target.value);
        }}
      />
    </FormField>
  );
};
```

## Build a generic input with constraint

You can use the prop `min` and `max` to defines a minimal and maximal value for your input and then leverage the [validation constraint API](https://developer.mozilla.org/en-US/docs/Web/HTML/Constraint_validation) to verify if the input meets the defined constraints.

<Preview>
  <DemoNumberConstraint />
</Preview>

```tsx
const Demo = () => {
  const [value, setValue] = useState(0);

  return (
    <FormField label="Quantity">
      <Input
        placeholder="Enter a quantity"
        type="number" // [!code highlight]
        min={3} // [!code highlight]
        max={5} // [!code highlight]
        value={value}
        onChange={(event) => {
          if (event.target.checkValidity()) {
            // [!code highlight]
            setValue(
              Number.isNaN(event.target.valueAsNumber)
                ? ""
                : event.target.valueAsNumber
            );
          }
        }}
      />
    </FormField>
  );
};
```

You can also use the prop `pattern` for text input:

<Preview>
  <DemoStringConstraint />
</Preview>

```tsx
const Demo = () => {
  const [value, setValue] = useState("");

  return (
    <FormField label="Name">
      <Input
        placeholder="Enter a name"
        type="text" // [!code highlight]
        // Only lowercase letters, with a maximum length of 8 characters.
        pattern="[a-w]{0,8}" // [!code highlight]
        value={value}
        onChange={(event) => {
          if (event.target.checkValidity()) {
            // [!code highlight]
            setValue(event.target.value);
          }
        }}
      />
    </FormField>
  );
};
```
